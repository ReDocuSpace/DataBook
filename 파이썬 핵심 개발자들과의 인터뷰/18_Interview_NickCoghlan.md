# 인터뷰 내용 - [파이썬 핵심 개발자들과의 인터뷰](https://product.kyobobook.co.kr/detail/S000001800633) 참조


## 컴퓨터 프로그래머가 되기로 결심한 이유가 무엇인가요?

원래 저는 어렸을 때, 그저 놀려고 프로그래밍을 했습니다. 애플 IIe를 위한 오래된 훌륭한 베이직 프로그래밍 책이 있었거든요.

고등학교 첫 해에 IT를 하기 전까지 저는 컴퓨터를 가지고 노는 것이 직업이 될 수 있다는 것을 몰랐습니다. 제가 간 학교는 저희 주에서 IT 수업을 실제로 운영하던 첫 번째 학교였어요. 그것이 제가 컴퓨터 시스템 엔지니어링으로 대학에진학하게 된 주 이유입니다.

대학을 졸업하고 가진 첫 풀-타임 직업은 텍사스 인스트러먼트Texas Instruments DSP(Digital Signal Processor)에서 C로 임베디드 시스템 프로그래밍을 하는 것이었습니다. 그곳에서 저는 임베디드 소프트웨어 개발보다 더 프로그래밍에 가까운 시스템 제어와 자동화 작업을 많이 하게 되었죠. 이것이 제가 프로그래밍을 즐겼던 하나의 사례이며, 꽤 일을 잘 했고, 돈을 벌 수 있었습니다.

---
## 	파이썬으로 전환한 이유가 무엇인가요?

저는 원래 C/C++ 개발자였기 때문에 파이썬으로 전환한 방법이 꽤 흥미롭습니다.

### '저는 이렇게 답했죠, “그냥 다른 언어를 쓰면 안될까요? 전 이미 자바를 알고있고, 자바를 쓰고 싶습니다.”'

대학에서 파이썬을 접했던 경험은 네트워킹 강사가 이렇게 말했을 때 뿐입니다. “저는 여러분들 모두에게 파이썬 과제를 줄 것입니다. 아무도 파이썬을 모를 것이라고 확신하기 때문입니다.” 저는 이렇게 답했죠, “그냥 다른 언어를 쓰면 안될까요? 전 이미 자바Java를 알고 있고, 자바를 쓰고 싶습니다.”

강사가 이렇게 말했죠, “글쎄요, 자바를 정말 쓰고 싶다면, 써도 됩니다. 하지만, 파이썬으로 먼저 해보세요”. 그래서 파이썬 1.5.2를 사용했고, 재미있었습니다.

저는 업무적으로는 여기 호주에서 대규모 시스템 통합기를 만들고 있습니다. 제가 작업했던 DSP 프로그램에는 끝이 보이지 않는 정말 기초적인 C 프로그램으로 작성된 테스트 묶음이 있었습니다.

통합 테스트 다음 단계로 넘어갈 때, DSP 코드는 많은 문제점과 함께 제대로 동작하지 않았습니다. 그래서 엄청난 양의 버그를 갖게 되었죠. 저희는 오디오를 넣기 위해 더 나은 테스트 묶음을 작성할 필요가 있다고 결정했습니다. 단순히 원격으로 DSP가 잘 동작하는지 확인하는 것 말고, 실 데이터 분석을 통해 기대한 답을 얻고 있다는 것을 확인하는 것이 중요했습니다.

### '실 데이터 분석을 통해 기대한 답을 얻고 있다는 것을 확인하는 것이 중요했습니다.'

저희는 실제 신호 프로세싱 자체를 확인하고 싶었어요. 그리고, C와 C++로 작성하고 싶지 않았습니다. 시스템의 다른 부분에서 파이썬이 시스템 제어 컴포넌트를 위한 언어라는 것이 이미 검증되어져 있었습니다. 파이썬을 핵심적인 부분에 사용하지는 않았지만, 시스템의 서로 다른 부분들을 조정하고 있었으며, 파이썬을 사용했으면 하는 곳에서 이미 사용하기 시작했습니다.

자동화 테스트를 하기 위해 찾고 있었던 옵션이 2개가 있었습니다. 하나는 파이썬의 unittest 모듈을 SWIG1와 함께 사용하여, DSP와 실제로 대화할 수 있는 C++ 드라이버로 바인딩하는 것이었죠. 다른 옵션은 기존에 모든 곳에 사용하던 자체 C/C++ 테스트 프레임워크였습니다. 저희는 파이썬을 선택했어요.

---
## 	왜 파이썬을 선택했나요?
	
파이썬은 테스팅을 실제로 조직화할 수 있는 unittest 모듈을 가지고 있었기 때문입니다. 파이썬은 SWIG를 C++ 드라이버에 묶어 놓을 수 있었습니다. 저희는 그 드라이버의 API를 제어해서 간단하게 SWIG를 테스트할 수 있었습니다.

파이썬을 선택한 마지막 주요 원인은 표준 라이브러리에 PC 밖으로 WAV 파일을 끄집어 낼 수 있는 wave 모듈 때문입니다. 그래서 호주의 고주파 현대화 프로젝트(High Frequency Modernization Project)의 전체 프로젝트를 위한 모범 사례를 만들었어요. 파이썬은 결국 프로젝트의 모든 곳에서 테스팅 목적으로 수행하는 테스팅, 목킹mocking과 시스템 인터페이스 시뮬레이팅을 통해 빠르게 확산되었습니다.

---
## 	다른 호주 개발자가 “pywin32”를 만드는 것을 도왔다고 알고 있습니다. 그 프로젝트에 참여하였나요?

아니요, 저는 “pywin32” 사용자일 뿐입니다. 역사적으로 파이썬 커뮤니티에 기여한 호주인이 정말 많습니다. 하지만, 파이콘 호주나 이와 비슷한 행사에서 활동이 많지 않기 때문에, 그들을 실제로 만날 수 없었습니다!

---
## 음, 다음으로 넘어가죠. 어떻게 파이썬 언어의 코어 개발자가 되었나요?

제 짧은 답은 귀도 반 로섬과 논쟁을 하면서 코어 개발자가 되었다는 것입니다!

### '귀도 반 로섬과 논쟁을 하면서 코어 개발자가 되었다는 것입니다!'

실제로 무슨일이 벌어졌는지 말씀드릴게요. 1990년대 후반에 유즈넷2에 있었고, 저는 온라인 토론 방식에 굉장히 익숙했었습니다. 파이썬을 시작한 이후, 결국 공식 파이썬 메일링 리스트에 합류하고, 토론에 참여하게 되었죠.

저는 파이썬-데브(Python-Dev)가 엄청난 메일 리스트인 것을 알게 되었고, 처음에는 사람들이 무슨 대화를 하는지 듣기만 했습니다. 그러다가 실제 토론에 활동적으로 참여하고, 포스팅도 하기 시작했죠. 파이썬 리스트 타입에 관한 토론이 제가 기억하는 첫 기여 활동입니다.

한 때, timeit 모듈을 사용하여 코드의 수행시간을 측정하고, “이 방법이 저 방법보다 더 빨라”라고 말하는 것이 굉장히 흔했어요. 그 당시, 2개의 다른 버전 소스 코드의 속도를 측정하고 싶으면, 표준 라이브러리의 해당 버전에 timeit 모듈이 어디있는지 찾아야 했습니다.

저희는 이렇게 말했죠. “잠시만! 파이썬은 timeit 모듈이 어디 있는지 이미 알고 있다고. 왜 파이썬에게 그 모듈이 어디있는지 찾아보라고 말해야 하지?” 그래서 결국 파이썬 2.4에 “-m” 스위치의 초기 버전이 추가된 패치가 생겼습니다. 레이몬드 헤팅거Raymond Hettinger가 검토한 걸로 기억합니다. 이 초기 버전은 최상위-레벨 모듈만을 지원했고, 패키지나 서브모듈은 사용할 수가 없었어요. 그러고 나서 마침내 파이썬 2.7에서 “-m” 스위치가 제대로 동작하게 되었고, 제약 없이 사용할 수 있게 되었습니다.

### '마침내 파이썬 2.7에서 “-m” 스위치가 제대로 동작하게 되었고, 제약 없이 사용할 수 있게 되었습니다.'

2004년 후반에 흥미로운 일이 일어났어요. 업무상 바쁜 기간이 지나고, 3개월간 일을 쉬었습니다. 저는 파이썬 “decimal”의 초기 성능 개선을 진행하던 레이몬드와 파쿤도 바티스타Facundo Batista를 돕게 되었습니다. 저희는 모듈을 빠르게 만드는 방법을 찾고 있었죠.

---
## 속도를 빠르게 할 방법을 찾았나요?

몇년 후에 최종 해결책을 찾았지만, 그 당시 초기 시절에는 다음과 같이 말하는 벤치마킹이 많았습니다. “순수 파이썬만 사용하면 얼마나 빠르게 만들 수 있을까?”

### '다음과 같이 말하는 벤치마킹이 많았습니다. “순수 파이썬만 사용하면 얼마나 빠르게 만들 수 있을까?”'

그 당시 눈부신 편법이 있었던 것으로 기억해요. 저희는 digit을 가진 튜플tuple을 십진수로 변경하고 싶은 경우, 순수 파이썬에서 씨파이썬CPython이 제공하는 가장 빠른 전환 메커니즘은 모든 digit을 문자열로 바꾸고 연결한 뒤, int를 사용하여 연결된 문자열을 다시 숫자로 변경하는 방법이 있다는 것을 발견했어요.

이 방법이 가능했던 이유는 파이썬 코드에서 문자열을 int로 전환하는 것이, 모든 곱셈과 덧셈 연산자를 수행하는 것 보다 더 최적화되어 있기 때문이었습니다. 물론, C에서는 그냥 연산arithmetic하면 됩니다. 저희가 발견한 것은 파이파이PyPy 개발자들을 정말 약 오르게 했죠. 그들의 관점에서는 파이파이의 컴파일러인 JIT에서 지원하는 연산을 하는 것이 훨씬 좋았습니다. 이는 decimal 모듈이 그들이 생각했던 것보다 더 느렸다는 것을 의미합니다.

파이썬 2.3이 나온 뒤부터 토론에 참여하기 시작했어요. 인기있는 취미 중 하나는 슬라이스slice 문법을 확장하면서 즐거워하는 것이었습니다. 시퀀스를 뒤집기 위한 뒤집어진 스마일리 이모지([::-1])가 있습니다. 이는 reversed 또는 비슷한 것이 나오기 오래 전부터 있었습니다.

슬라이스에서 뒤집기 연산을 바르게 하는 것이 꽤 까다로웠기 때문에, reversed는 물건이 되었습니다. 이 작업을 수작업으로 하면, 줄줄히 발생하는 에러를 만나기 정말 쉬웠거든요. 그냥 reversed를 호출하는 것이 소스 코드 읽기에도 수월했습니다.

---
## 파이썬 2.7의 긴 수명을 어떻게 생각하나요? 최신 버전으로 전환해야 하나요?
	
저희는 기존 사용자가 파이썬 3 생태계의 성숙도를 고려하여, 전환 유무를 스스로 결정할 수 있도록 충분한 시간을 제공했습니다.

### '저희는 기존 사용자가 파이썬 3 생태계의 성숙도를 고려하여, 전환 유무를 스스로 결정할 수 있도록 충분한 시간을 제공했습니다.'

초기에 사람들은 파이썬 2.7의 제약이 많은 마이그레이션으로 인해 힘들어 했습니다. 그래서, 현재 마이그레이션을 고려하는 사람들 대부분은 해당 프로세스를 도울 수 있는 더 나은 도구를 찾거나, 단순히 파이썬 2.7이 영향을 미치는 프로젝트나 제품의 소멸 계획을 세우는 시점에 다다랐습니다.

도구 관점에서는 파이썬 3의 타입 힌트 메커니즘의 활용 사례로, 자동 테스트 커버리지가 낮더라도 사람들에게 정적으로 파이썬 3 타입 정확성 에러를 확인할 수 있게 하는 것입니다. 이것이 확실하게 마이그레이션할 수 있는 코드 범위를 최대한 확장하는 방법입니다.

---
## 	미래의 파이썬 릴리즈에서 보고 싶은 변화가 있나요?

저는 부분적으로 구조화된 계층 데이터를 다루는 더 나은 도구를 보고 싶습니다만, 실행 가능한 수도 코드로서의 파이썬 명성을 지속하는 방법이 필요할 것입니다. 또한, 확장 모듈로 할 수 있는 것과 파이썬 소스 모듈을 반드시 요구하는 것 사이의 불일치를 꾸준히 줄여나가면 좋겠네요.

마지막으로, 보안 경계를 알려주는 것 대신, 메모리를 보호할 수 있는 관리 모델이 제공되면 좋겠습니다. 지금은 메모리 분리를 통해, 동시성 코드의 정확성 관리를 돕고 있죠.

씨파이썬의 하위 번역기가 이미 이 기능을 어느정도 제공하고 있습니다만, 현재 에릭 스노우Eric Snow가 해결 방법을 찾고 있는 사용성 관련 도전 과제들이 많습니다.

---
## 정말 좋군요! 제가 당신과 같은 코어 개발자가 되고 싶다고 해보죠. 무엇을 해야 하나요?

가장 중요한 것은 왜 코어 개발자가 되고 싶은지 찾아내는 것입니다. 이 질문의 답이 꼭 필요합니다. 왜냐하면, 당신이 다음과 같이 얘기하면서 필연적으로 좌절감을 느낄 것이기 때문입니다. “도대체 내가 이 짓을 왜 하고 있지?!”

만약, 여러분의 동기가 무엇인지 모른다면, 문제가 될 것입니다! 어느 누구도 여러분을 위해 그 질문의 답을 해줄 수 없습니다. 그 지점을 넘어서면, 코어 개발자가 된다는 것의 핵심은 대부분 믿음과 믿음을 얻는 과정에 있습니다.

### '코어 개발자가 된다는 것의 핵심은 대부분 믿음과 믿음을 얻는 과정에 있습니다.'

단순 기여를 하는 경우는 코어 검토자가 보통 이렇게 말할 것입니다, “이 변화를 받아들이고, 미래에도 관리를 할 것인가요? 나중에 누군가가 묻는다면, 우리가 이 변화를 수용한 합당한 근거를 제시할 수 있나요?”

신규 코어 개발자나 코어 검토자의 후보가 올라왔을 때, 저희가 살펴보는 것은 믿을만한 좋은 판단을 할 수 있는 능력입니다. 저희는 그들이 이렇게 말하기를 바래요, “네, 모든 것을 감안했을 때, 이것은 미래 파이썬 사용자에게 더 나은 삶을 가져다 줄 적절한 변화가 될 것입니다.”

프로그래밍 언어 설계는 트레이드-오프 게임입니다. 한꺼번에 모든 것을 최적화하고 싶다면, 아무것도 최적화할 수 없을 것입니다. 그래서 ,시간이 흐름에 따라 파이썬답게 만드는 트레이드-오프로 인해 수면위로 올라오는 것들이 많을 것입니다. 스스로 무엇을 할 지 결정하거나, 파이썬-데브(Python-Dev)에 토론을 위해 문제를 가져갈 필요가 있다는 것을 이해하는 것이 중요합니다.

### '프로그래밍 언어 설계는 트레이드-오프 게임입니다. 한꺼번에 모든 것을 최적화하고 싶다면, 아무것도 최적화할 수 없을 것입니다.'

그러고나면 다음과 같이 마지막 관문이 남습니다.

“이 제안은 충분히 까다로운 제안이며, 중요한 세부 사항들을 포함하고 있습니다. 잠재적인 논란이 충분히 예상되니, 다른 그 어떤 것도 하기 전에, 우리는 이 문제를 반드시 파이썬 개선 제안서(Python Enhancement Proposal)로 넘겨야 하며, 상세사항들을 다뤄야만 합니다.”

궁극적으로 코어 개발자는 특정 변화를 반영할 영역이 어딘지 결정합니다.

### '궁극적으로 코어 개발자는 특정 변화를 반영할 영역이 어딘지 결정합니다.'

---
## 코어 개발자는 어떻게 그 결정을 내리나요?

글쎄요, 버그 수정은 무엇인가 잘 못 되었다는 것을 알기 때문에 꽤 단순합니다. 하지만 버그 수정이라고 할지라도, 종종 혼란스럽죠.

저희는 믿음의 3가지 근거가 있습니다. 참조 번역기의 동작 방식, 테스트 묶음에서 명시한 것 그리고 문서가 말하고 있는 것이 바로 그것입니다. 3개가 모두 일치한다면, 하려고 하는 작업이 일관성이 있다는 것을 알게 되는 것이죠.

설계 판단의 문제가 되기 시작하는 곳은 번역기는 동작하지만, 테스트 묶음과 문서가 침묵을 지킬 때 입니다. 이 경우는 테스트가 되지 않았고, 특정 기능을 수행한다는 문서화가 되지 않았다는 것입니다. 다른 경우는 문서가 어떤 기능을 한다고 말하고 있지만, 테스트나 구현체는 무언가 다른 것을 하는 경우죠. 이런 경우에는 이렇게 말해야 합니다, “음, 문서는 맞지만, 버그인건가요, 아니면 문서가 단지 잘못된 건가요?”

이런 것들이 코어 개발자가 하는 일입니다. 반면에 여러분이 기여자일 때는 그저 아이디어를 반영하고 싶어할 거에요. 여전히 믿음 관리의 질문이지만, 여러분은 여러분의 변경 사항이 가치가 있다는 것을 검토자에게 설득해야합니다. 그래서, 정말 재미있죠!

여러분은 코어 개발자가 되는 것이 무엇을 수반하고 있고, 왜 그것이 여러분이 원하는 것인지를 이해할 필요가 있습니다. 역할의 실질적인 방법을 확인하려면, 브렛 캐넌이 BSF 펀딩을 받아서 작성한 개발자 가이드(Dev Guide)가 있습니다. 개발자 가이드는 시간이 흐르면서 관리되고 개선되고 있으며, 씨파이썬의 핵심 개발자와 기여자가 되는 것의 다른 점을 설명하고 있습니다.

### '코어 개발자가 되는 것에는 추가 의무가 부여됩니다.'

코어 개발자가 되는 것에는 추가 의무가 부여됩니다. 이슈를 다루고, 검토자와 함께 일하며, 검토 프로세스를 이해하고, 메일링 리스트의 토론에 참여하며 의사 결정을 하는 것이 포함됩니다. 실제로 굉장히 큰 프로젝트 일을 하면서 피할 수 없는 좌절감을 제어해야 합니다.

코어 멘토십 메일링 리스트 역시 여러분이 어떤 종류의 사람인지에 따라서 유용할 수 있습니다.

---
## 저는 항상 파이썬 개선 제안서(PEP)에 관심이 있었습니다. PEP의 생성 방법과 수용 절차를 설명해줄 수 있나요?

그럼요, 파이썬 개선 제안서(PEP)에는 대표적인 두 개의 흐름이 있습니다.

### '한 흐름은 코어 개발자가 우리가 만들고 싶어하는 것을 인지한 변화에 대한 제안이면서, 규모가 크고 복잡할 것이라는 것을 아는 경우입니다.'

한 흐름은 코어 개발자가 변경하려는 내용을 이미 알고 있고, 규모와 복잡도가 클 것을 예상하고 있는 제안인 경우입니다. 이런 경우에는, PEP를 작성하기 시작하고, PEP 리포지토리에 PEP를 등록합니다.

그러면 Python-ideas3에서 토론이 시작됩니다, “이봐, 내가 이 것을 제안하려고 신규 PEP를 작성했고, 여기 그 이유가 있어.” 토론은 보통 기본적으로 그 수준에서 시작됩니다. 코어 개발자들은 PEP 프로세스를 관리합니다. 왜냐하면, 그것을 몇 번 겪었으며, 이 변화가 자격을 얻기 위해 충분히 커지는 순간이 언제인지 알고 있기 때문입니다.

다른 PEP는 대개 누군가 Python-ideas에서 제안을 할 때 생성됩니다. 이 제안은 Python-ideas 글타래에서 한동안 머물게 될 것입니다. 그러고 나서 사람들이 이렇게 말합니다, “그거 아세요, 이 제안은 잠재적으로 좋은 아이디어가 될 수 있을 것 같아요!” 그러면, 이슈 트래커에 단순히 이슈를 등록하는 것 대신, 아이디어를 제대로 된 PEP로 옮기고, 아이디어를 제안하는 것으로 결정됩니다.

이렇게 말하고 보니, 실제로 PEP가 생기는 세 번째 방법이 기억이 나는군요. 저희가 바꾸고 싶지만, 까탈스러운 것이 많이 있을 때 이슈 트래커 상의 토론에서 나올 수 있습니다. 저희는 PEP를 작성하며, 상세한 것들을 철저히 검토한 뒤, 이 PEP를 아이디어 구현의 설계 자료로 사용합니다.

---
## 	결국 이러한 변화들을 깔끔하게 정리한 뒤, 수용하거나 거절하는 거군요?

제안에 따라 달라집니다. 어떤 제안은 논란이 많지 않지만, 단순히 상세 사항을 철저히 검토할 필요가 있어요.

이런 제안은 보통 Python-ideas와 파이썬-데브(Python-Dev)에서 토론이 진행됩니다. 아이디어 검토가 끝나면, 구체화하기 시작합니다. 제안은 수락된 PEP가 되며, 결국 마지막 단계에 다다르죠.

어떤 제안들은 경계에 머물게 되며, 파이썬-데브에서 이 제안이 좋은 아이디어인지 토론하게 됩니다. 저희는 실제로 제안이 열리는 순간에는 널 복합(null coalescing) 연산자에 대입됩니다. 즉, 진정으로 이 제안을 진행하고 싶은지 알 수가 없어요. 이 제안은 언어를 복잡하게 만들 수 있습니다, 왜냐하면 사람들이 배우고 이해해야 하는 아리송한 문법을 가지고 있기 때문입니다. 결국, 논쟁을 통해 그 아이디어를 반대하게 됩니다. 하지만, 인기 있는 논쟁에서는 이렇게 얘기합니다. “음, 이것은 데이터 처리 파이프라인에서 상당히 자주 올라오는 패턴이네.”

이 PEP는 파이썬-데브에 마지막으로 예 혹은 아니오 질문이 올라오기 전까지 토론을 계속 합니다. 그러고 나서 변경을 하지 않는 이상, 확실히 진행하고 싶으면 예를, 아니면 아니오로 결정을 내립니다.

### '아주 가끔, 확실히 거절하기 위해 작성한 PEP를 봅니다.'

아주 가끔, 확실히 거절하기 위해 작성한 PEP를 봅니다. 아이디어는 계속 올라오지만, 이를 반대하는 논쟁이 어떤 곳에도 명확하게 문서화가 되어 있지 않기 때문에 거절하기 위한 PEP를 작성하는 것이죠. 그래서 누군가가 이렇게 얘기하기 전에 아이디어를 읽고 거절하는 모든 이유를 적습니다, “그래! 나는 우리가 이 제안을 받아들이지 않는 이유를 말하기 위해서, PEP를 거절했다는 글을 올려야 겠어.” 그러고보니, 파이썬 3.5와 3.6에서 제가 본 신규 기능 중에 일부가 받아 들여지고 임시(provisional) 패키지로 분류된 것이 기억나는 군요.

---
## 거절하는 것과 임시 패키지로 분류되는 것이 어떻게 다른건가요? 사람들이 추가하고 싶은 것을 충분히 동의했지만, 유지할 수 없을지도 모른다는 것을 의미하나요?

그렇죠, 그래서 저희는 변경사항과 새로운 API를 받아들일 때 여러번 목덜미를 잡혔었고, 그 즉시 표준 하위 버전 호환성 보장 프로그램에 올려 놓았습니다.

결국, 저희는 피할 수 없는 막다른 골목에 다다르게 되었습니다. 해결하기로 한 문제에 그리 도움이 되지 않던 API를 지원하는 것에 문제가 생겼죠. 저희는 명확하게 혜택을 가져다 주며, 명확하게 사용자에게 도움이 될만한 제안들과 잠재적으로 모듈을 추가하는 것을 받아들이고 있었습니다. 문제는 저희가 API 설계 상세 사항을 잘 모르고 있었던 것이죠.

### '해결하기로 한 문제에 그리 도움이 되지 않던 API를 지원하는 것에 문제가 생겼죠.'

저희는 그 중 어떤 것도 전체 표준 라이브러리 하위버전 호환성 보장 프로그램에 두고 싶지 않았기에 추가하지 않기로 결정했습니다. 반드시 표준 라이브러리 안에 있어야 할 것들이, 표준 라이브러리 밖에 있었기 때문에 이 시도는 모두에게 결국 도움이 되지 않던 것이었습니다.

이 모듈 타입은 표준 라이브러리의 다른 부분을 개선하기 위해서도 사용할 수 없었습니다. 솔직하게, 표준 라이브러리에 신규 빌딩 블록을 집어 넣는 것은 표준 라이브러리의 다른 부분을 사용하고 싶기 때문입니다. 그래서 현재 표준 라이브러리에 enum 타입이 있죠. 소켓 모듈 안에서 사용할 수 있는 enum 타입을 원했기 때문입니다.

결국 PEP 4114이 되었던 임시 패키지 PEP는 몇 번의 이터레이션을 거쳤습니다. 기본적으로 PEP 411은 우리가 유지할 것이라고 확신하지만, 아직 API 설계 상세 사항을 갖지 못한 모듈을 수락할 수 있는 능력을 주기 위해 설계 되었습니다.

몇 번의 릴리즈 동안 PEP를 임시로 지정해놓고, 무언가 잘못된 것이 있다면, 스스로 고칠 수 있는 기회를 주었습니다. async I/O는 파이썬 3.6에서 임시 패키지에서 벗어난 유일한 패키지라고 생각합니다.

### '몇 번의 릴리즈 동안 PEP를 임시로 지정해놓고, 무언가 잘못된 것이 있다면 스스로 고칠 수 있는 기회를 주었습니다.'

---
## 	PEP를 임시로 지정하는 것이 잘 동작하던가요?

	
네, 이것이 동작하는 것을 보고, 정말 행복했어요. 사람들에게 이 PEP가 아직 변경될 수 있는 여지가 있다는 명확한 경고를 줄 수 있었죠. 사용자에게 아직 이 기능의 상세 사항을 처리하고 있다는 것을 알게 해주었으며, 만약 이 기능이 그들을 귀찮게 하면, 그 PEP를 아직 사용하면 안되는 것이었습니다.

실제로 파이썬 3.6에 흥미로운 최근 예제가 있네요. 바로 pathlib입니다. pathlib은 임시 API로 추가되었으며, 문자열로 데이터를 주고 받고 싶은 다른 표준 라이브러리 API들과 데이터 상호 처리를 하는데 많은 문제가 있었습니다.

### '파이썬 3.6에서 “pathlib”은 갈림길에 도달했습니다.'

파이썬 3.6에서 pathlib은 갈림길에 도달했고, 다시 표준 라이브러리 밖으로 끄집어 내고 순수 파이피아이PyPI 모듈로 되돌리거나, 데이터 상호 처리 이슈들을 수정해야만 했습니다. 이는 파이썬 3.6의 코어 개발팀이 다루기 전에, 반드시 하나를 선택해야하는 상황이었습니다.

이 결정은 기본적으로 pathlib의 데이터 상호 처리 이슈를 고치는 os.path 프로토콜 혹은 os.fspath 프로토콜과 path-like 객체를 지원하는 것이 되었습니다. 이는 수많은 표준 라이브러리 API들이 현재 자동으로 path-like 객체를 사용할 수 있다는 것을 의미합니다.

---
## 	좋습니다, 파이썬 패키징 위원회Python Packaging Authority5는 무엇인가요?

파이썬 패키징 위원회는 사실 핍pip과 virtualenv 개발자들의 농담에서 시작한 이름입니다. 그들은 두 프로젝트의 개발 팀 모두에게 사용할 수 있는 이름을 원했습니다. 그래서, 그들은 이렇게 말했죠, “우리를 ‘파이썬 패키징 위원회’로 부르자고, 아무도 이 이름이 될 것이라고 기대하지 않으니까!”

2013년, 저희는 setuptools와 distutils와 같은 도구들을 더 많이 만드려고 노력했어요. 파이썬 패키징 사용자 가이드Python Packaging User Guide는 패키징을 하기 위해 더욱 일관성있고 공식적인 권장 방법을 제공하기 위해서, 모든 정보를 한 곳으로 모으기 시작했습니다. 이 그룹을 대표하는 이름 역시 필요했죠. 저희는 파이썬 패키징 위원회가 끝내주는 이름이라고 생각했고, 더 많은 프로젝트를 해당 이름 아래로 편입하기 시작했습니다.

### '저희는 파이썬 패키징 위원회가 끝내주는 이름이라고 생각했고, 더 많은 프로젝트를 해당 이름 아래로 편입하기 시작했습니다.'

기본적으로, 파이썬 패키징 위원회는 패키징 도구와 표준과의 데이터 상호 처리를 책임지는 역할을 부여 받았습니다. 이는 마치 파이썬 코어 개발자가 수행하는 역할과 유사합니다. 프로그래밍 언어 디자인과 소프트웨어 배포 디자인에 관심을 가진 사람들 간에 중복되는 영역이 있었지만, 많은 사람이 한 쪽으로만 치우치려고 했습니다. 그리고 다른 쪽에는 아예 관심이 없었죠.

사람들을 두 가지 유형으로 나눈다는 것은 양쪽 디자인 타입에 영향을 받는 사람이 양쪽 하위 커뮤니티에 참여할 수 있다는 것을 의미합니다. 하지만, 우리는 끊임없이 소프트웨어 배포의 복잡성을 언어 설계자들에게 설명하지 않습니다. 반대로도 그렇고요. 이러한 분리는 일반적으로 사람들을 행복하게 만든다고 생각해요. 본인이 이해하는 그룹에 참여하는 것이 좋습니다. 저는 패키징을 좋아합니다만, 파이썬 역시 좋아하죠. 어느 것을 선택해야 할지 갈피를 못 잡겠군요. 아마도 저는 파이썬과 파이썬 패키징 위원회 모두에서 일하고 싶을 것입니다.

### '저는 패키징을 좋아합니다만, 파이썬 역시 좋아하죠. 어느 것을 선택해야 할지 갈피를 못 잡겠군요.'

---
## 	파이썬은 인공지능과 기계학습에서 사용하는 주요 언어 중 하나입니다. 이유가 무엇이라고 생각하나요?

	
인공지능과 기계학습은 탐구의 대화형 데이터 분석과 중대한 대량 데이터 고속 처리를 흥미롭게 섞어 놓은 것입니다. 씨파이썬의 풍부한 C API는 파이썬이 C, C++, 포트란Fortran과 같은 언어로 작성된 고성능 컴포넌트와 서로 연결하기 위한 ‘접착’ 언어로 쓰일 수 있게 해줍니다.

과학 연구 커뮤니티는 이 방식으로 파이썬을 20년 넘게 사용하고 있습니다(넘파이Numpy의 전신인 뉴메릭Numeric의 첫 릴리즈는 1995년이었습니다). 이는 파이썬이 유연성을 위한 독특한 하이브리드, 여전히 쉽게 배울수 있는 범용적인 컴퓨팅 언어를 제공하며, 고성능 컴퓨팅 환경을 위해 개발된 과학 컴퓨팅 라이브러리의 집합과 조합할 수 있다는 것을 의미합니다.

---
## 	파이썬이 인공지능과 기계학습을 위해 더 나은 언어가 되려면 무엇을 해야 할까요?

	
사용성 측면에서 모든 설정이 이미 되어 있는 프리미엄freemium6 웹 서비스(예 : 구글 콜라바토리7 혹은 마이크로소프트 애저 노트북스8)나 로컬 환경의 파이썬과 콘다Conda 패키징 도구 사슬을 통해서 사용자가 더욱 손쉽게 사용할 수 있는 컴포넌트를 만들 기회가 여전히 많습니다.

성능 측면에서는, 씨파이썬 번역기와 싸이썬 정적 컴파일러를 더욱 최적화하는 도전을 할 기회가 많이 없었습니다(예를 들어, 싸이선은 현재 공유 동적 런타임을 사용하기 때문에, 모듈을 생성할 때 보일러플레이트boilerplate 코드9가 많습니다, 이는 단지 덩치를 키우고 컴파일을 느리게하는 것 뿐만아니라, 런타임시 탑재하는 것도 느려지게 합니다).

---
## 	저와 블로거 친구더군요. 파이썬에 관해서 글을 얼마나 오랫동안 썼나요? 그리고 왜 블로거가 되었나요?
	
블로그에 프로그래밍 관련 글을 올리기 시작한 것이 아마 파이썬 3.3 쯤이에요. 대부분, 글을 쓰는 것은 생각하는 것을 돕는 매우 쓸모 있는 보조 도구인 것을 알게 되었죠. 읽기 좋은 충분히 논리 정연한 아이디어를 갖게 됩니다. 이것이 지금도 블로그를 사용하는 주 이유입니다. 나중에 참조하고 싶은 파이썬에 관한 특정 내용이 있으면, 현재 생각을 적습니다.

---
## 	실제로 파이썬이 프로그래밍을 처음 배우기에 좋은 언어인가요?

저는 파이썬을 첫 텍스트-기반 언어로써 강력하게 추천합니다. 만약, 프로그래밍의 기본 개념을 이해하고 싶다면, 플러그 앤 플레이plug-and-play 언어로 시작하는 것도 좋은 대안입니다.

### '일단, 완전한 조합 프로그램을 만들고 싶다면, 파이썬은 매우 좋은 언어입니다.'

일단, 완전한 조합(combinational) 프로그램을 만들고 싶다면 파이썬은 매우 좋은 언어입니다. 의도적인 언어 설계 제약은 그리 전망이 밝지 않습니다. 먼 곳에서 아주 복잡한 행동을 분석할 수 없죠. 언어학을 공부하면, 인간의 뇌 또한 먼 곳에서 복잡한 것을 분석하는 것이 어렵다는 것을 알게 됩니다.

파이썬의 장점은 소스 코드를 읽는 것만으로도 문맥을 이해할 수 있다는 것입니다. 즉, 소스 코드의 의미를 파악하기 위해, 복잡한 것들을 머리 속에 집어 넣고, 다시 꺼낼 필요가 없다는 거죠. 저희는 모든 것을 눈에 잘 띄는 곳에 놓으려고 노력합니다. 이러한 노력은 사람들이 생각해 낸 아이디어를 머리 속에 쉽게 넣을 수 있도록 도와주는 놀라운 차이를 만든다고 생각해요.

몇 년 전에 스크립팅 언어와 적절한 복잡성에 관한 포스트를 썼습니다. 쿡북 혹은 작업 지시 가이드를 보면, 절차적인 명령어를 보게 될 것입니다. 쿡북이 외부로 노출하는 계층은 매우 절차적이고 순차적입니다. 그렇게 되면, 하위 함수와 객체들이 그 틀 안에 내장되어 있는 것과 같이 되어 버리죠. 파이썬은 우리가 세상과 상호 작용하는 방법을 반영하기 때문에 사람에게 더 잘 어울린다고 생각합니다.

### '파이썬은 우리가 세상과 상호 작용하는 방법을 반영하기 때문에 사람에게 더 잘 어울린다고 생각합니다.'

---
## 	파이썬이 잘 어울린다는 것이 어떤 의미인지 조금 더 설명해주시겠어요?

그럼요, 우리는 보통 절차적으로 행동합니다. 절차적으로 시작하면 필요한 것이 가장 위에 올라오게 계층이 나눠지게 되며, 이치에 맞게 되는 것이죠.

객체 지향 프로그래밍, 함수형 프로그래밍과 이벤트 기반 프로그래밍은 복잡성을 관리하기 위해 태어났습니다. 언어를 위한 기본 원칙으로써 어떤 것을 선택하더라도 만들고자 하는 프로그램의 복잡성을 최소 수준으로 설정하게 됩니다.

로보틱스와 임바디드embodied 컴퓨팅 타입 환경을 가르치는 사람들과 대화를 나누는 것은 무척 흥미롭습니다. 이것들을 가르치려면, 객체를 사용하는 것이 좋은 방법입니다. 임바디드 컴퓨팅 사람들은 자연스럽게 이렇게 이야기하죠, “저 로봇은 내 프로그램안에 ‘Robot’ 클래스에 따라서 책상에 앉아 있어.” 그들은 소스 코드로 작성한 것을 눈으로 보여줄 수 있습니다.

기본적으로 절차적인 이 사례가 쿡북과 지시 가이드가 작성된 방법과 정말 일치한다고 생각해요. 진입 장벽을 낮추는 것도 좋지만, 동시에 파이썬은 여러분과 함께 성장할 수 있는 언어입니다. 파이썬은 수학적 프로그래밍, 객체 지향 프로그래밍과 함수형 프로그래밍을 모두 할 수 있는 모든 도구를 가지고 있습니다.

### '파이썬은 여러분과 함께 성장할 수 있는 언어입니다.'

여러분이 가지고 있는 문제점 기반으로 파이썬을 사용할 수 있습니다. 파이썬의 한가지 관점에 관하여 배우기 시작할 때, 특정 영역의 언어를 커스터마이징하기 위해 삽입하는 용도로 활용할 수 있습니다. 즉, 파이썬을 하스켈(함수형 프로그래밍), 자바 혹은 C# 안에 집어 넣기 위해 사용할 수 있습니다.

---
## 	제가 모든 파이썬 기초 지식을 알고 있고, 이제 언어를 더 깊이 이해하고 싶다고 가정해보죠. 무엇을 해야 하나요?
	
이 시점에 스스로 물어야할 중요한 질문은, ‘어떻게 배우느냐’입니다. 예를 들어, 저는 스스로 필요-기반 학습을 하고 있다는 것을 알았습니다.

### '문제를 해결하기 위해서, 새로운 프로그래밍 기술과 신규 라이브러리들을 배우죠.'

저는 단지 지식 습득을 목적으로 무언가를 배우지 못합니다. 보통, 문제를 해결하기 위해서, 새로운 프로그래밍 기술과 신규 라이브러리들을 배우죠. 제 경우는, 해결하고 싶은 문제점을 찾으면, 문제를 해결하기 위해 필요한 것은 무엇이든지 배웁니다.

앨리슨 캡투르Allison Kaptur가 효율적인 배움 전략에 관하여 꽤 좋은 글을 썼었죠. 저희는 데브 가이드에 파이썬 내부를 깊이 다루기 위하여 알아야 할 내용을 담은 섹션을 추가하기 시작했습니다. 한가지 유용한 지름길은 여러분이 매일 사용하는 오픈 소스 라이브러리를 살펴 보고, 코드를 훑어 보기 시작하는 것입니다.

### '여러분이 매일 사용하는 오픈 소스 라이브러리를 살펴 보고, 코드를 훑어 보기 시작하는 것입니다.'

표준 라이브러리에는 표준 라이브러리 모듈 문서와 소스 코드를 연결하는 링크가 있기 마련입니다. 해당 링크를 클릭하여 문서를 읽으면서, 이 소스 코드가 어떻게 작성되었는지 알아보는 것만으로도 도움이 됩니다.

파이썬 튜터(pythontutor.com)라고 불리는 흥미로운 프로젝트가 기억나는군요. 파이썬 튜터는 코드 시각화 도구 혹은 행위 시각화 도구입니다. 코드 작업을 하는 동안, 실시간으로 소스 코드 변경 사항을 저장하여 나중에 어떤 변경 사항이 벌어지고 있는지 확인할 수 있는 도구죠.

파이썬 튜터의 전략은 소스 코드를 변경하는 이유가 실제로 변경하기 위함이 아니라, 그저 어떻게 동작하는지 확인하기 위함이라는 것을 알 수 있어서 유용합니다.

---
## 오늘날 파이썬에 관하여 가장 흥분되는 것은 무엇인가요?

답을 두 가지로 구분하여 드리겠습니다. 전문가로서의 견해와 개인 관점에서의 견해가 조금 다르거든요.

리눅스 생태계가 엔터프라이즈 회사에 녹아 들어간 것과 같은 방법으로, 파이썬은 리눅스 생태계의 일부가 되었습니다. 더 이상 엔터프라이즈 회사 경영진에게 파이썬을 구차하게 설명할 필요가 없죠. 지금까지 달성한 모든 것이 큰 기업과 기관의 간헐적인 투자와 자원한 커뮤니티 기여자들 덕분입니다.

### '지금까지 달성한 모든 것이 자원한 커뮤니티 기여자들 덕분입니다.'

전문가로서의 견해로는, 비즈니스 소프트웨어 개발의 인공지능과 기계학습 기술의 사용이 늘어나고 있다는 사실이 가장 저를 흥분시킵니다. 수많은 조직이 C, C++, 자바와 C#을 재탕하는 현재 엔터프라이즈 소프트웨어보다 더 많은 것이 소프트웨어 개발 세계에 있다는 것을 깨달았습니다.

이는 최근 IEEE 스펙트럼의 연간 다중-데이터-소스 언어 순위를 통해서 더욱 명확하게 확인할 수 있습니다. 2014년에 파이썬이 (C#과 함께) 상위 5위에 랭킹되었지만, 2017년 조사에는 다른 언어 모두를 제치고 1위 자리를 차지하고 있습니다.

개인적으로는, 오픈소스 파이썬 커뮤니티에 선생님과 교육자들이 직접 참여하고 있다는 것이 저를 가장 흥분시킵니다.

수많은 파이썬 사용자 그룹 역시 성인 교육에 초점을 맞추고 있으며, 현재 업무를 더 잘하고 싶은 사람들이나 소프트웨어 개발로 직업 전환을 고려하고 있는 사람들의 컴퓨팅 기술력 향상을 위한 워크숍을 제공하고 있습니다.



---
## 

---
## 

---

1    SWIG : Simplified Wrapper and Interface Generator), C나 C++로 작성된 컴퓨터 프로그램이나 라이브러리들을 루아, 펄, PHP, 파이썬, R, 루비, Tcl과 같은 스크립트 언어 및 C#, 자바, 자바스크립트, Go, 모듈러-3, Ocaml, 옥타브, Scilab, 스킴 등의 다른 언어들과 연결하는데 사용하는 오픈 소스 소프트웨어 도구
2    유즈넷(usenet) : 유저 네트워크의 준말, 주로 텍스트 형태의 기사들을 전 세계의 사용자들이 공개된 공간에서 주고 받아 토론할 수 있게 고안된 분산 네트워크
3    Python ideas 메일링 리스트 : 파이썬의 언어적인 아이디어를 토론하는 메일 리스트, https://mail.python.org/mailman/listinfo/python-ideas
4    PEP 411 : https://www.python.org/dev/peps/pep-0411/
5    파이썬 패키징 위원회(Python Packaging Authority, PyPA) : https://www.pypa.io/en/latest/
6    프리미엄(freemium) : 기본 서비스는 무료로 제공하고 추가 고급 기능에 대해서는 요금을 받는 서비스 종류
7    구글 콜라바토리(Google Colaboratory) : 머신러닝 교육과 연구를 위한 연구 도구. 쥬피터 노트북 환경이므로 설치 없이 사용할 수 있다, https://colab.research.google.com/
8    마이크로소프트 애저 노트북(Microsoft Azure Notebook) : 쥬피터 노트북을 애저기반으로 사용할 수 있는 서비스, https://notebooks.azure.com/
9    보일러플레이트(boilerplate) 코드 : 비즈니스 로직과 같이 특화된 내용은 포함하고 있지 않으나, 소스 코드 작성을 위해 문법상 반드시 포함해야하며, 여러 곳에 등장하는 코드 섹션을 뜻하는 프로그래밍 용어


---

- 메모리 보호 : 메모리를 보호한다는 의미는 메모리에 담겨있는 데이터가 의도하지 않게 값이 변경되는 것을 방지한다는 뜻이며, 보통 병렬 분산 처리를 하는 다중 쓰레드를 사용할 때 관련 이슈가 많이 발생한다. 다른 언어는 '접근 제한자'와 같은 설정으로 메모리를 보호할 수 있지만, 파이썬은 상대적으로 이 부분이 약하며, 도전해야 할 보완점이라는 것을 이야기하고 있다.