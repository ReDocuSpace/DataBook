# 인터뷰 내용 - [파이썬 핵심 개발자들과의 인터뷰](https://product.kyobobook.co.kr/detail/S000001800633) 참조


## 당신의 배경부터 시작해보죠. 왜 프로그래머가 되었나요?

글쎄요, 어렸을 때 학교 친구가 자기가 쓰던 애플 IIe를 팔려고 했습니다. 저는 프로그래밍을 해 본적이 전혀 없었지만, 그 중고 컴퓨터를 사기로 했죠. 그때가 14살이었습니다.

저는 베이직BASIC과 어셈블리assembly가 정말 흥미로웠습니다. 명령어 프롬포트가 있었고, 어셈블리 코드를 작성하기 위해, 어셈블리 과정을 이해할 수 있는 수준까지 깊이 파고들 수 있었어요. 저는 프로그래밍 방법이 담긴 컴퓨터 매뉴얼을 많이 읽었습니다. 작은 프로그램을 만들려고 노력했고, 그래서 파스칼Pascal을 알게 됩니다. 정말 즐거웠습니다.

고등학교 5학년(16살) 때, 학교 선생님이 로고Logo1라고 불리는 언어로 무언가를 해보라고 했어요. 이 언어는 기본적으로 그래픽 명령어를 사용하여 펜을 오른쪽, 왼쪽으로 움직이면서 줄을 그렸습니다. 저는 시뮬레이션 루프를 만들었고, 작은 비행기가 날아가면서 폭탄을 떨어뜨리는 것처럼 보이게 하는 프로그램을 만들었습니다. 무척 간단하지만 즐거웠고, 선생님은 감동을 받았죠.

이것이 제가 프로그래밍 세계에 발을 딛게 된 계기입니다. 어떤 면에서는 거의 기회라고 볼 수 있죠. 그 당시, 프로그래밍은 그저 취미였습니다. 왜냐하면, 물리학을 배우는 것이 목표였거든요.

---
## 	결국 어떻게 파이썬을 하게 되었나요?

회사 업무로 윈도우의 그래픽 사용자 인터페이스(GUI) 개발을 할 필요가 있는 프로젝트가 있었습니다.

이전 10년동안, 저는 유닉스에서 C++로 커맨드 라인과 3D 그래픽 애플리케이션 대부분을 개발했었지만, 메뉴-기반 애플리케이션은 (자바Java AWT2로 작성한 GUI를 제외하고) 개발하지 않았습니다. 저는 정말 MFC3가 두려웠어요, 그래서, 윈도우에서 그 작업을 할 수 있는 옵션들을 찾기 시작했죠. 저는 파이썬과 Tk를 (플랫폼 독립적이였기 때문에) 우연히 발견하게 되었습니다.

### '파이썬은 완벽하게 잘 맞는 도구였어요. 파이썬을 보자마자, 단순함과 깨끗한 문법에 깊이 공감하였습니다.'

파이썬은 완벽하게 잘 맞는 도구였어요. 파이썬을 보자마자, 단순함과 깨끗한 문법에 깊이 공감하였습니다. 제 사고 방식과 일치했는지는 모르겠군요. 저는 wxPython도 찾았고, API가 꽤 견고해 보였습니다. 파이썬과 wxPython을 사용하여 빠르게 인터페이스를 생성할 수 있는 능력을 좋아하게 되었습니다.

그래서, 저는 C++보다 파이썬으로 더욱 쉽게 요구 사항을 달성할 수 있는 업무 프로젝트를 수행하면서 파이썬을 알게 되었습니다.

---
## 	wxPython 커뮤니티에 참여하게 된 것도 같은 이유인가요?

네, 그렇습니다. 저는 그 프로젝트의 결과물로 wxPython으로 제 첫 애플리케이션을 개발했어요. 시트 온도와 에어콘을 분석하기 위한 애플리케이션이었습니다. 그 당시, 자동차 시트 편의성을 위해 이런 종류의 소프트웨어를 사용하여 시제품을 만들고 있었어요.

그래서 저는 wxPython을 사용했고, wxPython이 지원하던 발행publish-구독subscribe 패턴은 정말 굉장한 아이디어였습니다. 저는 그 라이브러리의 Pubsub 컴포넌트를 넘겨 받으면서 wxPython 개발에 깊이 관여하게 됩니다.

### '저는 그 라이브러리의 Pubsub 컴포넌트를 넘겨 받으면서 wxPython 개발에 깊이 관여하게 됩니다.'

---
## 그럼 Pubsub은 다른 사람이 시작했었나요?

네, 롭 셱터Robb Shecter가 Pubsub의 첫 버전을 만들었습니다. 그 당시 원인을 찾아야 했던 이슈가 있었고(대부분, 메모리 릭 이슈 : subscriber가 애플리케이션에 더 이상 필요 없는데도 릴리즈되지 않는 현상), 저는 중요한 패치와 단위 테스트를 제안했습니다. 롭은 wx.lib.pubsub을 넘겨 받을 사람을 찾고 있었습니다. 그래서 제가 받았죠.

---
## 	그때가 Pubsub이 wxPython에서 벗어나 자체 모듈로 분리된 시점인가요?

몇 년 후로 기억합니다. Pubsub은 독립적인 하위-패키지에 가깝습니다. 반면에, 다른 wx.lib 하위-패키지들은 다른 wxPython 컴포넌트를 의존하고 있었죠. 저는 wx.lib.pubsub을 더 넓은 범위의 개발자들이 사용할 수 있게 만들고 싶었고, wxPython 개발자들이 동의했습니다.

### 'Pubsub은 독립적인 하위-패키지에 가깝습니다.'

---
## 그 당시, 파이디스패처PyDispatcher 프로젝트를 알고 있었나요?

글쎄요, 저는 언젠가부터 파이디스패처를 알게 되었습니다. 꽤 다른 접근 방식을 취하고 있었죠.

그 당시 파이디스패처는 토픽-기반이 아니었습니다. Pubsub은 분리된 패키지로 정의되기 때문에 많이 달랐죠. 파이디스패처를 살펴 본 지 좀 되었지만, 현재 모습이 어떨지 궁금하군요.

토픽, 메시징 그리고 (MQTT와 구글 pub/sub과 같은) 발행/구독의 기본적인 아이디어를 사용하는 프로젝트가 여러 개 있습니다만, 네트워크 관점에서 보았을 때 이들은 애플리케이션 간의 통신을 처리하는 것에 반하여, Pypubsub은 애플리케이션 내에 컴포넌트 레벨에서 통신을 처리합니다. 그들은 Pubsub이 진화한 것보다 훨씬 더 진화했습니다. Pypubsub은 안정적이고 운영 환경에서 사용할 수 있는 품질을 가지고 있습니다.

---
## 제 블로그(the PyDev of the Week) 시리즈에서 저와 한 인터뷰에서 알았습니다만, PyQt4로 전환하셨습니다. 무슨 일이 있었나요?

그때가 2013년이에요. 클라이언트가 가지고 있던 오래된 프로토타입을 현대화하는 프로젝트가 있었습니다. 애플리케이션에는 프로토타입에 의해 실행이 되는 파이썬 사용자-정의 스크립트가 있었습니다. 그렇기 때문에, 동일한 출력 결과를 보장한다는 전제하에 파이썬 번역기를 애플리케이션에 집어넣거나, 전체 파이썬 스크립트를 다른 언어로 바꿔야만 했습니다(이 작업은 프로젝트 예산을 벗어나는 것이었죠).

### '파이썬 번역기를 애플리케이션에 집어넣거나, 전체 파이썬 스크립트를 다른 언어로 바꿔야만 했습니다.'

그래픽 인터페이스는 매우 정교해야 했습니다. 그 당시에, 프로토타입에는 사용자가 모델 컴포넌트를 3D 환경에서 회전할 수 있는 3D 컴포넌트가 있었습니다. 사용자가 상호 작용할 수 있는 메뉴, 리스트 뷰와 함께 그래픽 사용자 인터페이스를 정교한 2D와 3D 캔버스로 통합해야 했죠.

저희는 활성화된 커뮤니티 기반으로 안정적이고, 강력하면서, 문서화가 잘 되어 있는 무언가를 원했습니다. 그 당시, WPF, wxPython 그리고 PyQt (혹은 C++ 인프라를 위한 Qt)가 주요 후보들이었죠. C# 쪽에는 WPF가 있었습니다. 여러 다양한 시도를 한 뒤, 결국 wxPython과 PyQt의 사이에 다다랐죠.

PyQt는 wxPython보다 3D 환경에 더 강력하게 통합할 수 있었습니다. 또한, PyQt는 3D 장면 그래프를 지원하기 위해 빠르게 성장하고 있는 반면에, wxPython을 사용하면 OpenGL을 쓸 수 밖에 없었고, 더 복잡했습니다. 파이썬 3는 필수적이었지만, 그 당시 로빈 던Robin Dunn이 wxPython 3를 만들기로 결정한 것을 기억합니다. 그래서, 파이썬 3 지원이 조금 이른 시점이었죠. 기본적으로 wxPython은 파이썬 2.7만을 사용할 수 있었습니다. 반면에, PyQt를 사용하면, Qt 디자이너도 사용할 수 있었고, 이는 제품 선정의 주요 이유가 되었죠. PyQt는 디자인을 생성하기 위한 매우 정교한 인터페이스를 가지고 있었습니다.

### 'PyQt는 확실히 유명해지고 있었습니다.'

XML-주도 사용자 인터페이스 명세는 PyQt와 WPF 모두 지원하고 있었어요.

PyQt는 확실히 유명해지고 있었고, 패키지의 상용 사용이 가능했습니다. 이것이 중요했죠. WPF는 예전에 위젯에 속성값을 바인딩할 때 고생을 많이해서 부정적이었습니다. 물론, 아이언파이썬IronPython이 방치되고 있는 징조도 있었어요. 모든 것을 고려하고, PyQt를 선택했습니다. 올바른 결정이었어요.

---
## 	Pypubsub 부분으로 돌아가보죠, 여쭤보는 것을 잊었군요. 혹시 이 오픈소스 프로젝트를 수행할 때 나누고 싶은 도전이 있었나요?

기술적인 도전은 아니었지만, 오픈소스 개발 관점에서 흥미로운 경험을 했습니다. 이 경험으로 인해 제가 스스로 개척한 오픈소스 분야이더라도, 제가 원하는 방향으로 제어할 수 없다는 것을 다시 한번 깨달았습니다.

### '제가 스스로 개척한 오픈소스 분야이더라도, 제가 원하는 방향으로 제어할 수 없다는 것을 다시 한번 깨달았습니다.'

Pypubsub은 wxPython 안에서 불렸듯이 이름이 단순하게 “pubsub”일 때, 소스포지SourceForge5에 있었습니다. 파이피아이에 올릴 때 제가 Pypubsub으로 이름을 지었죠. 몇 년 후, 저는 소스포지에 Pypubsub으로 불리는 다른 프로젝트가 있다는 것을 발견했습니다. 기본적으로, 그 프로젝트는 죽은 프로젝트였고, 가끔 스택 오버플로Stack Overflow와 두 Pypubsub 포럼에서 혼란을 일으키기도 했죠.

이를 바로 잡기 위해 노력이 필요했습니다. 저는 프로젝트를 만든 저자에게 연락해서 무슨 일이 벌어지고 있는지 설명했습니다. 결국, 그의 동의하에 소스포지의 “pypubsub” 프로젝트의 오너십을 가질 수 있었습니다.

그런 와중에, 깃허브GitHub가 정말 유명해졌어요. 어떤 사람들이 편리성을 위해서 제 Pypubsub 소스 코드를 복사해서 깃허브에 올려 놓았습니다. 그것이 잘못된 것은 아니었지만, 그들은 기능을 추가하지 않았습니다. 제가 실제로 깃허브에 Pypubsub을 옮기기로 결정하였을 때, 일부 개발자들에게 Pypubsub을 마침내 깃허브에서도 사용할 수 있게 되었다고 알려야 했어요. 소스 코드 복제본이 분리되어 있어야 할 이유가 더 이상 없다는 것을 설명했습니다. 이러한 경험은 오픈소스의 흥미로운 부분이기도 합니다.

---
## 프로젝트에 얼마나 시간을 할애했나요?

글쎄요, 지난 15년간 소스 구현체와 확장 API의 주요 수정(버그 수정, 문서 업데이트와 파이썬 신규 릴리즈에 테스트 전수 검사)을 하기 위해 투자한 시간이 적지 않습니다. 시간을 내는 것이 그리 쉽지 않더군요. 하지만, 이러한 부분도 자원하여 일을 하는 또 하나의 묘미가 아닌가 싶습니다.

wxPython의 저자인 로빈은 API가 진화하더라도 하위 버전 호환성을 항상 지키라고 요구했고, 저 역시 Pypubsub이 wxPython과 완전히 분리되었음에도 불구하고, 하위 버전 호환성을 지키는 것이 매우 중요하다고 생각했습니다. 이를 가능케 하는 것이 기술적인 주요 도전이었습니다. 그래서 Pubsub이 단 3개의 API/메시징 프로토콜을 가지게 되었죠.

### '하위 버전 호환성을 지키는 것이 기술적인 주요 도전이었습니다.'

첫째로, Pubsub의 가장 첫 버전에는 하위 버전 호환성이 있었습니다. 그것을 저는 ‘버전 1 메시징 프로토콜’이라고 부릅니다. 그리고, “현대” Pubsub에는 API에 중요한 개선 사항이 있는데, 여기에 2개의 API가 있습니다

하나는 모든 메시지 데이터가 하나의 큰 blob6 형태로 sendMessage() 함수에 전달되기 때문에 arg1으로 불렸습니다. 다른 것은 sentMessage() 함수에 키워드 인수로 전달이 되었기 때문에 kwargs라고 불렸습니다. Pypubsub 스탠드얼론을 설치하면 kwargs가 기본 설정입니다.

---
## 	왜 이 전환을 가능하게 만드는데 집중했나요?

왜냐하면, 저도 한 프로젝트에서 애플리케이션을 개발할 때 같은 문제를 풀기 위한 도전을 했기 때문입니다. 그 애플리케이션은 arg1 프로토콜을 사용하고 있었고, 신규 kwargs 프로토콜로 마이그레이션을 하는 중이었습니다. 그리 복잡한 작업은 아니었지만, 다소 지루하고 오류가 발생하기 쉬웠습니다. 이러한 에러 검증 로직을 추가하고 전환을 진행하는 것은 kwargs API의 장점 때문에 충분히 가치있는 일이었습니다.

저는 Pypubsub 모듈을 탑재할 때, 매개 변수를 설정하여 중재(in-between) 작업을 활용하는 아이디어를 제시했고, 프로토콜 변경 작업을 할 때 무척 유용했습니다. 덕분에 전체 시스템을 서서히 kwargs로 전환할 수 있었습니다.

### '소스 코드는 제가 원했던 것보다 훨씬 더 복잡했습니다.'

안정적인 API를 확보하는 일에는 어느 정도의 노력이 필요합니다. 소스 코드가 제가 원했던 것보다 훨씬 더 복잡했고 저에게 좌절감을 안겨주었으며, 관리가 더 힘들어지고, Pypubsub을 통한 호출을 추적하기가 더욱 힘들어졌습니다. 또한, 애플리케이션 개발 완료를 원하던 사람들의 발목을 잡기도 하였죠.

저는 시간이 허락한다면, 오래된 소스 코드 모두를 버리자(deprecate)고 제안하였습니다. 왜냐하면, 오래된 API는 wxPython 앱에만 쓸모가 있었기 때문입니다. 로빈이 동의했죠. 2016년, 저는 “버전 1”과 arg1 프로토콜을 위한 모든 지원을 그만두고, 코드 베이스의 주요한 소스 코드를 정리(clean up)하고 간단하게 다듬었습니다.

---
## 최근에 참여한 다른 파이썬 프로젝트에 관하여 이야기해주시겠어요?

물론입니다, 하나는 정말 훌륭하게 마무리된 프로젝트로, 아주 정교한 GUI를 가지고 있으며, 기술적으로 매우 큰 도전이었습니다. 사실 최근 몇 년동안 PyQt 작업을 하는 이유를 토론하는 자리에서 간접적으로 언급했었죠.

그 애플리케이션은 박스를 드롭(drop) 할 수 있는 캔버스가 있었고, 박스들을 서로 연결할 수 있었습니다. 마이크로소프트 비지오8와 같은 도구와 다른 점은 사용자가 원할 때 애니메이션처럼 박스를 변경하면서 프로세스를 보여줄 수 있게 프로그램할 수 있다는 겁니다.

사용자는 이것을 파이썬 스크립트로 정의할 수 있습니다. 애플리케이션은 각각의 사용자 스크립트에 현재 사용 가능한 파이썬 네임스페이스를 추가하기 때문에, (동적으로 모델이 바뀔때 속성에 반영되는 코드 자동 완성 기능처럼) 사용자가 기본 모델을 동적으로 조회할 수 있습니다.

### '애플리케이션은 각각의 사용자 스크립트에 사용 가능한 파이썬 네임스페이스를 추가하기 때문에, 사용자가 기본 모델을 동적으로 조회할 수 있습니다.'

모델 컴포넌트를 생성하고, 추가하며, 링크를 걸 수 있는 매우 정교한 인터페이스가 있습니다. 또한, 모델 편집의 서로 다른 관점을 위해, 아주 세밀한 취소(undo) 기능도 있어요.

### '늘 그렇듯이, 10%의 기능을 위해 90%의 개발 시간을 할애했습니다.'

저희는 사용자가 문서를 찾을때, 어떤 것이 취소 혹은 재실행(redo)되었는지 항상 볼 수 있게 했습니다. 이는 흥미로운 도전이었고, 늘 그렇듯이, 10%의 기능을 위해 90%의 개발 시간을 할애했습니다.

그 애플리케이션은 시뮬레이션 시스템이었어요, 그래서 그저 라인과 박스만 생성하는 것이 아니었습니다. 시뮬레이션을 관리하는 인터페이스 컴포넌트는 실시간 모델 변경, 초기 상태 복구, 변경 이력 조회 등이 있습니다.

그래서 애플리케이션에 굉장히 큰 기능들이 있죠. 하지만, PyQt는 훌륭하게 동작하였습니다.

---
## 그 프로젝트를 위해 사용한 Qt에 관하여 조금 설명해주시겠어요?

네, Qt의 그래픽 뷰는 기능 측면에서 정말 인상적이었죠.

초반에는 Qt를 어떻게 사용해야는지 항상 명확하지 않았던 것으로 기억합니다. 예를 들어, 다양한 작업을 할 수 있는 캔버스-기반 애플리케이션은 어느 순간이라도 작업 완료 여부를 확인하기 위해서 상태 기계state machine를 사용하는 것이 무척 유용합니다. 이를 깨닫기 위해 수년이 걸렸기 때문에 이 부분을 설명하는 문서가 없었습니다. Qt는 상태 기계를 내장하고 있지만, 저희의 필요성에 비해 그리 강력하지 않았다는 것을 말씀드리고 싶군요.

상태 기계는 유일하게 어떤 행동을 할 수 있는지, 상태를 정의할 수 있게 합니다. 그래서 “라인 생성”이라는 상태에는 생성 취소, 마우스 드래그, 혹은 대상 라인 선택만 할 수 있죠. 이 부분이 상태 기계가 빛나는 곳입니다. 상태 기계가 없다면, 코드가 결국 관리할 수 없는 스파게티 코드가 됩니다. 트러블슈팅과 신규 행동을 추가 확장하는 것이 훨씬 간단해지죠.

비록, Qt 문서가 훌륭했지만, 스스로 해결해야 하는 것들도 있었죠. “아 맞아, 어떻게 하는지 이제 이해했군. 구현했던 소스 코드를 다시 살펴보고 고쳐야겠어”라고 종종 말하게 됩니다. 결국 더 높은 수준의 기능들을 실제로 지원할 수 있는 더욱 탄탄한 구현체를 만들게 됩니다.

### '결국 더 높은 수준의 기능들을 실제로 지원할 수 있는 더욱 탄탄한 구현체를 만들게 됩니다.'

저는 Qt의 모든 위젯에 익숙해지기 시작했습니다. PyQt를 업그레이드 했을 때 찾은 끔찍한 버그가 있었어요. 이 버그는 드래그를 할 때 모든 라인이 보여서, 전체 인터페이스에 영향을 미쳤습니다. 이 버그는 말할 필요도 없이 큰 문제였지만, 다른 기능들을 위해 PyQt를 업데이트해야 했어요.

저희는 C++ 레이어까지 문제점을 추적했고, 엄청난 행운 덕택에 해결 방안을 찾았습니다. 파이썬 레벨에서 애플리케이션에 소스 한 줄을 추가해야 했죠. PyQt 소스 코드를 변경할 필요도 없었습니다. 이 한 줄의 코드를 추가하자마자 버그는 사라졌습니다. 저는 Qt에 버그를 보고했어요 : https://bugreports.qt.io/browse/QTBUG-55918.

Qt가 가지고 있는 또 하나의 매우 흥미로운 영역은 단위 테스트(unit test)입니다. 저희는 애플리케이션 GUI의 단위 테스트를 수행할 필요가 있었어요. 훌륭한 파이테스트pytest를 사용했고, 핵심 비즈니스 로직을 위한 하나의 테스트 묶음과 GUI 컴포넌트를 위한 묶음이 있었습니다. GUI 단위 테스트는 정말 큰 도전이 될 수 있습니다. 사용자 동작을 스크립트로 작성해야 하기 때문입니다.

운이 좋게도, Qt는 함수를 호출하는 것만으로도 모든 위젯 이벤트를 쉽게 실행할 수 있는 기능을 제공함으로써, 단위 테스트를 비교적 쉽게 해줍니다. 하지만, 이벤트 기반인 경우, 기대한 결과와 함께 수많은 사용자 동작을 정의할 방법이 필요했습니다. 그래서 저는 이를 지원하는 라이브러리를 만들었죠. 불행하게도, 소스가 닫혀서 코드를 공유할 수는 없지만, 이 아이디어를 PyQt 포럼에 언급했고, 그들 중 누군가가 그들의 방식에 맞춰서 구현을 했습니다.

---
## 파이썬은 인공지능과 기계학습에 사용되는 주요 언어 중 하나입니다. 이유가 무엇이라고 생각하시나요?

인공지능과 기계학습 앞에서 더 막강해지는 파이썬의 “신과 같은” 본질 때문이라고 말하고 싶습니다. 파이썬은 어쩌다 보니, 단지 한 두개가 아니라 수많은 필수 요소들을 갖춘 매우 강력한 언어가 되었거든요.

### '인공지능과 기계학습 앞에서 더 막강해지는 파이썬의 “신과 같은” 본질 때문입니다.'

예를 들어, 파이썬은 함수형, 절차형 혹은 객체지향 코딩을 어떤 조합으로도 할 수 있으며, 그 코드는 여전히 이해하기 쉽고 깔끔합니다. 게다가, 알고리듬과 데이터를 매우 쉽게 테스트하기 위해 컴파일을 할 필요도 없죠. 단지, 코드를 수정하고 스크립트를 재실행하면 됩니다.

결국, 파이썬은 간결한 문법으로 강력한 추상화를 제공하게 되었습니다. 제가 편협적일 수도 있겠지만, 저는 파이썬이 이 부분에서는 최고라고 생각해요. 저는 명시적이고 깨끗한 코드와 함께 리팩토링과 테스트를 자유롭게 할 수 있습니다. 이 모든 것을 가능케 한 강력함은 파이썬을 인공지능에 완벽하게 만들어줍니다.

---
## 인공지능과 기계학습을 위해 파이썬이 더 나은 언어가 되려면 무엇을 해야 할까요?

언어의 추상화 수준이 주어진 문제 도메인의 추상화 수준과 일치할 때, 언어는 가장 쓸모 있기 마련입니다.

만약, 딥러닝이 신경망을 사용한다면, 일반적인 신경망 개념을 가지고 있는 것이 매우 유용하겠죠. 이는 현재 텐서플로TensorFlow와 같은 라이브러리가 제공하고 있습니다. 하지만, 아마도 기계학습 알고리듬이 개선됨에 따라, 신경망을 위한 일반적인 추상화는 리스트나 맵과 같은 기본적인 데이터 구조가 될 것입니다.

또한, 저는 인공지능/기계학습 함수들이 “어떻게 그 결과에 도달했는지” 확인할 수 있는 능력이 필요하다고 생각해요. 이는 인간이 결과를 검증하는 방법이죠. 그들이 사용한 로직을 인지하고, 말로 표현할 수 있으며, 다른 사람이 이를 따르고, 정확성을 검증할 수 있습니다.

---
## 파이콘을 비롯한 여러 곳에서 대화를 나눈 사람들이 하나같이 데이터 과학 영역에서의 파이썬의 성장을 강조하고 있습니다. 이 영역에서 직접 하고 있는 일이 있나요? 아니면 어떤식으로든 견해를 밝혀 주실 수 있나요?

네, 파이썬은 데이터 과학 영역에서 정말 성장하고 있어요. 제 견해로는, 쥬피터Jupyter, 아나콘다Anaconda와 싸이킷-런sckikit-learn과 같은 도구가 주요 원인이라고 생각합니다.

아마도 컴퓨터의 거대한 연산 능력을 조합하면, 언어의 속도는 더 이상 문제가 되지 않을 것입니다. 파이썬은 임베디드 시스템에도 사용할 수 있으며, 원칙적으로 특정 디바이스에서 스스로 훈련된 기계 모델 기반의 예측 분석도 가능합니다.

### '컴퓨터의 거대한 연산 능력이 있다면, 언어의 속도는 더 이상 문제가 되지 않을 것입니다.'

2017년 파이콘에서 정말 흥미로운 발표9가 있었습니다. 발표자는 플롯팅plotting 라이브러리 현황을 조사하고 있었습니다. 그 조사는 매트플랏립matplotlib으로 시작해서 그 주위를 둘러싸고 있는 모든 것에 관한 것이었죠. 그러고 나서 자바스크립트 라이브러리로 넘어갔는데, 일부는 파이썬 라이브러리와 관련이 있었습니다. 저는 판다스pandas, 넘파이NumPy와 매트플랏립으로 만든 클라이언트가 있었기 때문에 이 발표에 많은 관심이 있었고, 정말 제 마음을 사로 잡았어요. 이는 추가할 여지가 있는 다른 확장 라이브러리와 계층(layer)이 많이 있다는 것을 보여주었습니다.

클라이언트 관점에서 얘기해보면, 원하는 것을 무엇이든지 만들 수 있고, 매트플랏립에 한정될 필요가 없습니다. 엄청 많은 것들이 있기 때문이죠. 이미 존재하는 것을 다시 발명할 필요도 없다는 것을 알고 있기 때문에 하고자 하는 일을 충분히 일반화해야 합니다. 통계 분석을 하고 싶다면, 쥬피터Jupyter나 R로도 할 수 있습니다. 이러한 기능들을 제공하는 적합한 애플리케이션을 만드는 노력을 항상 해야 합니다.

매트플랏립이 매우 다양하고, 고도로 발달한 API가 있다는 이유로 사용자에게 매트플랏립 사용을 강요하고 싶지 않을 것입니다. 하지만, 매트플랏립의 모든 기능을 제공하는 GUI 컴포넌트를 만드는 방법은 없습니다.

파이썬은 표현력이 풍부하고 무척 쉽게 배울 수 있는 언어입니다. 저는 이점이 현재 파이썬이 연구 영역 안에서 큰 부분을 차지하고, 연구 자체에 적용된 이유라고 생각합니다. 파이썬은 적용하기 쉽고, 정교하며, 기술적인 문제를 풀어줍니다.

### '파이썬은 표현력이 풍부하고 무척 쉽게 배울 수 있는 언어입니다. 저는 이점이 현재 파이썬이 연구 영역 안에서 큰 부분을 차지하고, 연구 자체에 적용된 이유라고 생각합니다.'

파이썬은 강력하고 결정적인 제품을 만들고 제공하기 위한 모든 도구를 제공합니다. 성능을 측정할 수 있고, 병목 지점을 찾거나 메모리 누수 유무를 확인할 수 있습니다. 파이썬을 정말 위대한 도구로 만들어주는 것들이 많습니다.

---
## 파이콘 발표 중에 기억에 남을 만한 발표가 또 있을까요?

파이콘 2017에 Global Interpreter Lock(GIL)에 관한 또 다른 흥미로운 발표10가 있었죠. 이론적으로, GIL을 제거하는 것은 무척 좋을 일입니다. 이는 파이썬 쓰레드를 분리된 코어에서 실행할 수 있게 하는 것을 말하죠.

### '이론적으로, GIL을 제거하는 것은 무척 좋은 일입니다.'

그러나, GIL은 매우 현실적인 문제를 해결하고 있습니다. 파이썬 데이터 구조의 접근(access)을 동기화하는 것과 같이 말이죠. 무엇이 필수적이며, 득과 실이 무엇인지 분석함으로써 GIL을 파고들기 시작하면, GIL이 수많은 것들을 매우 단순하게 만들었고, 파이썬으로 복잡한 소프트웨어를 만드는 것이 굉장히 쉬운 이유가 GIL 때문이라는 것을 깨닫게 됩니다.

여러분은 멀티-쓰레드 프로그래밍의 숨은 제약사항 없이, 기본적으로 동시성 프로그래밍을 할 수 있습니다. 규모가 큰 문제 대부분을 이런 방식으로 처리하고 싶죠. 다른 종류의 문제점으로는, 사소한 병렬화 문제를 해결하고 싶을 것입니다. 기본적으로 솔루션을 태스크로 쪼개는 곳에서 말이죠. 태스크간에 아주 작은 의존성이 있을 것이고, 매우 쉽게 태스크를 실행할 수 있을 것입니다.

몬테 카를로11를 좋은 예로 볼 수 있습니다. 시뮬레이션과 비즈니스 프로세스에서 매우 중요하기 때문입니다. 여러분은 거의 차이가 없는 작은 것들을 기본적으로 여러 번 실행하고 싶을 것이며, 파이썬은 이를 쉽게 해줍니다.

사소한 병렬화 문제를 위해, 이 작은 태스크들을 실행할 필요가 있습니다. 멀티프로세싱 모듈을 사용하는 것만으로도, 분리된 코어에서 실행할 수 있습니다. 네, 그렇게 할 수 있어요! 원칙상 복잡한 수많은 것들이 파이썬에서는 단순하며, 많은 태스크를 처리하는데 매우 유용합니다.

### '원칙상 복잡한 수많은 것들이 파이썬에서는 단순합니다.'

그러나, 저는 멀티프로세싱 모듈을 사용할 필요 없이 다중 코어에 파이썬 코드를 실행할 수 있는 쉬운 방법이 있다고 생각해요. 파이썬 내부 구조에 GIL과 긴밀하게 동작하는 곳을 살펴보면 답이 나오겠죠. 기술적으로 불가능한 것은 없습니다. 단, 실행을 하려면 커뮤니티의 합의가 반드시 필요합니다.

---
## 	오늘날 파이썬에 관하여 가장 기대되는 것은 무엇인가요?

선택적 타입 어노테이션 시스템, 비동기식 호출 그리고 멀티프로세싱 모듈이에요

---
## 파이썬의 가장 큰 경쟁 언어는 무엇인가요?

자바스크립트죠. 자바스크립트가 웹 영역을 지배하는 것이 정말 유감입니다. 웹의 자바스크립트와 기술적 컴퓨팅의 파이썬이 서로 경쟁하고 있습니다. 만약, 컴퓨터의 원초적인 연산 속도가 정말 필요하다면 C++를 쓸 수 있어요.

C++ 코드를 SWIG나 SIP를 사용12하여 파이썬에 주입하면, 수행 속도를 크게 향상시킬 수 있습니다. 싸이썬Cython도 있죠. 높은 수준의 추상화가 필요한 곳에서 파이썬을 사용하고, 컴퓨팅 파워는 C++로 가져오면 됩니다.

실은 지금 어디로 가고 있는지 잘 모르겠습니다. 자바스크립트 진영에서는 자바스크립트를 파이썬처럼 강력하고 쉽게 사용하기 위해 많은 시도를 하고 있지만, 다른 측면에서 보면, 파이썬이 웹 브라우저를 지원하는 언어가 되기 위한 노력은 보이지 않습니다. 자바스크립트가 너무 확고히 자리를 잡았기 때문입니다. 혹시 모르죠, 구글이 크롬에서 파이썬 코드가 실행될 수 있게 만들 수도 있겠죠.

### '자바스크립트 진영에서는 자바스크립트를 파이썬처럼 강력하고 쉽게 사용하기 위해 많은 시도를 하고 있습니다.'

---
## 	파이썬이 계속 살아남을 수 있을까요?

네, 그렇다고 생각해요. 파이썬은 무척 훌륭한 언어이고, 파이썬 커뮤니티가 개발한 좋은 품질의 견고한 라이브러리와 PEP13 기반의 언어 개선 프로세스가 존재합니다. 파이썬을 위한 매우 엄격한 프로세스가 있으며, 수많은 똑똑한 사람이 참여하고 있어요. 생존할 것이라고 확신합니다.

---
## 파이썬 2.7의 긴 수명에 관해서 어떻게 생각하시나요? 최신 버전으로 꼭 전환해야 할까요?

파이썬 2.7의 긴 수명은 가장 신경질나는 일이에요! 우분투와 구글 클라우드 플랫폼과 같이 영향력이 큰 조직부터 파이썬 3.6을 그들의 기본 버전으로 만들기 시작해야 합니다.

### '파이썬 2.7의 긴 수명은 가장 신경질나는 일이에요!'

---
## 미래 파이썬 릴리즈에서 보고 싶은 변화가 있나요?

저는 타입 추론과 함께 선택적 정적 타이핑 시스템(타입을 정의할 필요가 없는), 진정한 병렬성 그리고 선택적 컴파일 모드를 보고 싶군요.

선택적 정적 타이핑, 컴파일, 그리고 타입 추론의 조합은 언어를 시작할 때 단순하게 유지하면서, 필요하면 언어를 더욱 엄격하게 다룰 수 있게 합니다.

이는 실행 속도와 생산성에도 큰 장점을 제공합니다. 선택한 객체가 어떤 연산을 할 수 있는지 혹은 (함수 선언부 내에서) 어떤 연산이 필요한지 명시적으로 표기하는 것은 코드 실행 시간을 항상 줄여줍니다. 현실적으로, 타입을 미리 정의하는 컴파일 모드가 가능할지 모르겠습니다만, 믿을 수 없을 정도로 똑똑한 사람들이 있기 때문에 가능성을 배제하지 않겠습니다.

병렬성에 관해서는, 파이썬 코드를 GIL을 유지한 상태에서 다중 코어에 동시 다발적으로 실행할 수 있는 능력을 말하는 것입니다. 물론, 멀티프로세싱 모듈이 있죠, 하지만, 저는 일급 시민(first-class citizens)14 으로써 언어 내부에 구축되는 구조에 관하여 이야기한 것입니다.

---

1    로고(Logo) : 함수형 프로그래밍을 이용하는 교육용 컴퓨터 프로그래밍 언어, 리스프의 방언
2    AWT(Abstract Window Toolkit) : 자바의 기존 크로스-플랫폼 윈도우, 그래픽스, 사용자 인터페이스 위젯 툴킷
3    MFC(Microsoft Foundation Class Library) : 마이크로소프트에서 만든 윈도우 API를 C++로 둘러 싼 라이브러리
4    PyQy : Qt 크로스-플랫폼 C++ 프레임워크를 파이썬으로 바인딩하는 라이브러리,
https://www.riverbankcomputing.com/software/pyqt/intro
5    소스포지(SourceForge) : 소프트웨어 개발자들을 위해 열려있는, 오픈소스 소프트웨어 개발관리를 위한 플랫폼, https://sourceforge.net/
6    blob(Binary Large OBject) : 하나의 엔티티로서 저장되는 이진 데이터 객체, 일반적으로 그림, 오디오, 또는 기타 멀티미디어 오브젝트인 것이 보통이지만, 바이너리 실행 코드가 저장되기도 한다
7    코드 프리징 : 소프트웨어를 릴리즈하기 위해 소스 코드 변경을 모두 금지하는 순간을 프리징한다고 한다.
8    마이크로소프트 비지오 (Visio) : 마이크로소프트 윈도우에서 그림이나 도표를 그리는 소프트웨어
9    발표 링크 : https://youtu.be/FytuB8nFHPQ
10    발표 링크 : https://youtu.be/pLqv11ScGsQ
11    몬테 카를로(Monte Carlo) : 난수를 이용하여 함수의 값을 확률적으로 계산하는 알고리듬을 부르는 용어
12    SWIG : http://www.swig.org/tutorial.html / SIP : https://wiki.python.org/moin/SIP
13    PEP(Python Enhancement Proposals) : 파이썬 기능 개선을 위한 제안서, https://www.python.org/dev/peps/
14    일급 시민(first-calss citizen) : 일반적으로 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체를 가리킴. 함수에 매개변수로 넘기기, 변수에 대입하기와 같은 연산들이 여기서 말하는 일반적인 연산의 예에 해당한다. 일급 객체라고도 부른다.
---

- arg1 vs kwargs : 'arg1'은 인수가 하나라는 의미를 포함하는 반면에, 'kwargs'는 'keyword arguments'의 약자로 여러개의 키워드 인수를 함수에 전달할 수 있다는 것을 암시적으로 나타내고 있다. 키워드 인수는 파이썬의 독특한 함수 정의 방법으로, 인수에 기본값을 미리 설정하여, 함수 호출시 값을 전달하지 않으면 기본값이 쓰이는 파이썬 기본 기능이다.

순수 wxPython을 설치하면, 버전 1 API와 거의 100% 호환되기 때문에 arg1이 설치 됩니다. 설치 플래그는 Pypub sub을 탑재(import)하기 전에 kwargs 프로토콜을 선택하기 위해 애플리케이션 코드에 설정할 수 있습니다.

이 모든 것을 동작하게 하는 것은 큰 고통이었습니다. 기본적으로 “이 애플리케이션에는 arg1 프로토콜이 필요한데, 이 wxPython 애플리케이션에는 kwargs 프로토콜을 원해...”라고 말하는 사용자를 위해 라이브러리 탑재 방법을 조금 손볼 필요가 있었어요.

저는 wxPython 애플리케이션 버전 1에서 arg1 혹은 kwargs 프로토콜로 전환하는 것을 도와주는 코드도 추가하였습니다. 그 작업도 만만치 않았죠.

정말 하고 싶지 않은 일이었지만, 그 당시에는 반드시 해야하는 끔찍한 일이었습니다. 코드가 복잡해지는 것 이외에도, Pypubsub의 모듈 탑재 방식을 더 복잡하게 만들었고, 이는 소스 코드 프리징7을 방해할 수도 있었죠.

- 선택적 정적 타이핑, 컴파일 그리고 타입 추론 : 파이썬의 가장 큰 특징 중 하나는 ‘동적 타이핑'이며, 미리 변수의 데이터 타입을 지정하지 않고, 번역기에 의해 코드가 실행될 때 변수에 담겨 있는 데이터의 타입으로 ‘추론'하여 타입이 정해진다. 이는 소스 코딩시 개발 생산성을 향상하여 빠르고 쉽게 개발하는 것을 돕지만, 소스 코드의 실행 속도를 떨어뜨리는 주범이기도 하다. 그렇기 때문에, 데이터 타입을 미리 정의하는 ‘정적 타이핑'을 사용자가 선택할 수 있게 하고, 소스 코드를 미리 컴파일하여 바이너리 형태로 번역기 없이 실행할 수 있게 된다면, 언어의 실행 속도를 놀라울 정도로 향상시킬 수 있다는 것을 말하고 있다. 하지만, 이를 선택이 아닌 필수 사항으로 강제하면, 소스 코드가 복잡해지면서 가독성 및 개발 생산성이 떨어지기 때문에, 이를 ‘선택 사항'으로 남겨 놓아야 하는 것을 강조하고 있다.